---
title: C++ PRIMER 笔记
subtitle:
date: 2023-07-12T09:29:59+08:00
draft: true
author:
  name:
  link:
  email:
  avatar:
description:
keywords:
license:
comment: false
weight: 0
tags:
  - draft
categories:
  - draft
hiddenFromHomePage: false
hiddenFromSearch: false
summary:
resources:
  - name: featured-image
    src: featured-image.jpg
  - name: featured-image-preview
    src: featured-image-preview.jpg
toc: true
math: false
lightgallery: false
---

{{< admonition quote "quote" false >}}
note abstract info tip success question warning failure danger bug example quote
{{< /admonition >}}

<!--more-->



##

### 2.4

#### 2.4.2 指针和const




**const指针**

<u>常量指针(const pointer)</u>：必须初始化，存放在指针中的<font color=red>地址的值不能改变</font>

```c++
int *const curRrr = &errNumb;
const double *const pip = &pi;
```

#### 2.4.3 顶层const
  - 顶层const表示任意的对象是常量，这一点对任何数据类型都适用；底层const则是与指针和引用复合类型的基本类型部分有关；
  - 顶层const(top-level const)：指针本身是个常量(指针不可改变，地址不可改变, 仅仅对指针有效)
    - ```c++
      int * const p = &errNumb;
      const int p = 42;
      ```
  - 底层const(low-level const): 指针所指的对象是一个常量(对象的值不可改变)
    - ```c++
      const int *p = &errNumb;
      int const *p = &errNumb;
      ```
    - 对于底层const，拷入和拷出的对象必须具有相同的底层const资格

#### 2.4.4 constexpr 和 常量表达式
  - 常量表达式(const expression) 是指**值不会改变**并且在**编译过程**就能得到计算结果的表达式。
  - **constexpr变量**
    - C++11新标准规定，允许将变量声名为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。
  - **指针和constexpr**
  - 在constexpr声名中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关。

### 2.5 处理类型

#### 2.5.1 类型别名
`typedef`

`using`


指针、常量和类型别名

```
typedef char *pstring;
const pstring cstr = 0; //声明指向char的常量指针，其基本数据类型是指针
const char *cstr = 0; // 声明指向常量字符的指针，其基本数据类型是char
```

#### 2.5.2 auto 类型说明符

(c++11) `auto:` 让编译器通过初始值去分析表达式的所属类型。

复合类型、常量和auto

1. 以引用对象的类型作为初始值; 或者将引用的类型设为auto, `auto &g = ci`
2. auto一般会忽略顶层const， 底层const则会保留; 顶层const需要明确指出，例如`auto const f = ci`

<font color=red>符号&和*只是从属于某个声名符，而非基本数据类型的一部分</font>

#### 2.5.3 decltype类型指示符

(C++11)
类型说明符`decltype`: 选择并返回操作数的类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。
```c++
// sum的类型就是调用函数f() 返回的类型
delcltype(f()) sum = x;
```

> decltype处理顶层const和引用的方式和auto不同。如果decltype使用的表达式是一个变量，则decltype返回该变量类型(包括顶层const和引用)

```c++
const int ci = 0, &cj = ci;
decltype(ci) x = 0; //x的类型是const int
decltype(cj) y = x; // y的类型是const int &, y绑定到变量x
decltype(cj) z; //错误: z 是一个引用，必须初始化
```

decltype和引用

如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。

```c++
// decltype 可以是引用类型
int i = 42, *p = &i, &r = i;
decltype(r) z; //错误: z的类型是int&, 必须初始化
decltype(r + 0) b; // 正确， int
decltype(*p) c; //错误: c的类型是int&, 必须初始化
```

> 如果表达式的内容是解引用, 则decltype将得到引用类型。

### 2.6 自定义数据结构

#### 2.6.1

类数据成员

(c++11)可以为数据成员提供<u>类内初始值</u>

#### 2.6.2 使用sales_data类

#### 2.6.3 编写自己的头文件

  - 预处理器概述

    >`#include:`用指定文件代替#include
    >`#define:`把一个名字设定为预处理变量
    >`#ifdef:`当且仅当变量已定义时为真
    >`#ifndef:`当且仅当变量未定义时为真
    >`#endif:`一旦检查结果为真，则执行后续操作直到#endif指令为止

## chapter 3 字符串、向量和数组

### 3.1 命名空间的using声明
  - 作用域操作符`::`:编译器从操作符左侧名字所示的作用域中寻找右侧那个名字。

  - 使用using声明: `using namespace::name;`

  - 每个名字都需要独立的using声明。
    >头文件不应包含using声明，因为头文件会拷贝到所有引用它的文件中去，容易引起名字冲突。

### 3.2 标准库类型string

#### 3.2.1 定义和初始化string对象

**概念区分:** 直接初始化和拷贝初始化

  - 拷贝初始化：使用`=`初始化一个变量，编译器直接把等号右侧的初始值拷贝到新创建的变量中去。
  - 直接初始化： 不适用等号进行初始化

#### 3.2.2 string对象上的一些操作

**读写string对象**
  - 可以使用iostream读写string对象
  - 读取位置数量的string对象
    ```c++
    int main() {
        string word;
        while (cin >> word) {
            cout << word << endl;
        }
        return 0;
    }
    ```
  - 使用getline读取一整行: getline函数传入一个输入流和一个string对象，读取输入流直到遇到换行符，换行符也被读取进来，但是不存到string对象中
    ```c++
    int main() {
        string line;
        while (getline(cin, line)) {
            cout << line << endl;
        }
        return 0;
    }
    ```
  - string的`empty()`和`size()`操作
  - string::size_type类型： 一个无符号类型的值
  - 比较string对象：`==`、`!=`、`<`、`<=`、`>`、`>=`(比较大小按字典顺序)
  - 为string对象赋值
  - 两个string对象相加
  - 字面值和string对象相加：加法两面必须有一个是string对象
  ```c++
  string s1 = "hello";
  string s6 = s1 + ", " + "world"; // 正确: s1 + ", " 返回一个string对象
  string s7 = "hello" + "world"; // 错误: 加号码两边都是字面值，没有string对象
  ```

#### 3.2.3 处理string对象中的字符

  - 处理每个字符? 使用基于for循环：`for (char ch : string)`
  - 使用for循环改变字符串中的字符，必须把循环变量定义成引用类型：`for (auto& ch : string)`
  - 只处理一部分字符： 使用下标或索引
    - 使用下标执行迭代：
    - 使用下标执行随机访问：

### 3.3 标准库类型vector

### 3.4 迭代器介绍

#### 3.4.1 使用迭代器

  - begin() 和 end()
    - (c++11) const_iterator: cbegin() 和 cend();
  - 迭代器运算符:
    - `==` 和 `!=`：比较两个迭代器是否相等
    - `*iter`:
    - `iter->mem`
    - `++iter`
    - `--iter`
  - 迭代器类型:
    - iterator：对象可读可写
    - const_iterator: 能读取但是不能修改它所指元素的值
  - 结合解引用和成员访问操作
    - 解引用: *iter
    - 成员访问操作: (*it).empty()
    - `->`操作结合了解引用和成员访问操作: `it->mem` == `(*iter).mem`

#### 3.4.2 迭代器运算

  - 迭代器的算术运算: 迭代器和一个整数值相加，返回向前或者向后移动若干个位置的迭代器
  - 使用迭代器运算

### 3.5 数组

#### 3.5.1 定义和初始化内置数组

  - 声明数组: `a[d]` 声明时数组的维度必须是一个常量表达式
  - 显示初始化数组元素
  - 字符数组的特殊性: 声明时要加上空字符，如果没有则会被默认添加
  - 数组之间不允许拷贝和赋值;
  - 理解复杂的数组声明
    - 可以定义存放指针的数组 `int* p[10]`
      ```c++
      int *ptrs[10]; // 声明一个数组，存放十个指针
      int (*parray)[10] = &arr; // 声明一个含有十个整数数组的指针 parray是指针的名字，指向一个数组
      int (&arrRef)[10] = arr; // arrRef引用一个含有10个整数的数组
      int *(&arry)[10] = ptrs; // arry 是数组的引用，该数组含有10个指针
      ```

#### 3.5.2 访问数组元素

数组下标通常用size_t定义，size_t是一种机器相关的无符号数。

#### 3.5.3 指针和数组

  - 在使用数组的时候，编译器会把它转化为指针；
  - 在程序中用到数组名字的地方，编译器会把它替换为指向数组首元素的指针；
    ```c++
    string *p2 = nums; // 等价于 p2 = &nums[0]
    ```
  - 数组的操作实际上是指针的操作:
    - 当使用数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组；
    - 当用decltype关键字是上述转换不会发生，decltype(ia)返回的类型是由10个整数构成的数组；
      ```c++
      decltype(ia) ia3 = {0, 1, 2, 3,...}
      ```
  - 指针也是迭代器: 可以将数组元素的指针当做迭代器使用
  - 标准库函数begin 和 end
    - 数组不是类类型，因此这两个函数不是成员函数
      ```c++
      int ia[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
      int *beg = begin(ia);
      int *end = end(ia);
      ```
  - 指向数组元素的指针可以执行以下运算: 解引用、递增、比较、与整数相加、两个指针相减等
  - 解引用和指针运算的交互
  - 下标和指针


#### 3.5.4 C风格字符串

  - 字符串存放在字符数组中并以空字符结尾
  - C标准string函数<cstring>:
  - 比较字符串
    - 普通比较关系符用在c风格字符串上，其实比较的是两个指针的大小关系
    - 方法: 调用strcmp(): 相等返回0， 前面较大返回正值， 反之返回负值


#### 3.5.5 与旧代码的接口

  - 混用string和c风格字符串
  - 使用数组初始化vector对象

### 3.6 多维数组

  - 多维数组的初始化
  - 多维数组的下标引用
  - 使用for循环处理多维数组
    - 选用引用类型作为循环控制变量类型
  - 指针的多维数组
    - 多维数组的名字实际是指向第一维数组的指针
  - 类型别名简化多维数组指针

## chapter 4 表达式

### 4.1 基础

#### 4.1.1 基础概念

  - 一元运算符: 作用于一个运算对象
    - 例如: `&`取地址符、`*`解引用符
  - 二元运算符: 作用于两个运算对象
    - 例如：`==`相等运算符、`*`乘法运算符
  - 三元运算符
  - 函数调用也是一种运算符

  - 组合运算符和运算对象
  - 运算对象转换
  - <font color=red>重载运算符</font>: 当运算符作用于类类型时候，用户可以自定义其含义
  - <font color=red>左值和右值</font>: <u>当一个对象被用作右值的时候，用的是对象的值(内容)；当对象被用作左值的时候，用的是对象的身份(在内存中的地址)</u>
    - 重要原则: 在需要右值的地方可以用左值来代替，但是不能把右值当成左值使用；
    - 几个左值运算对象
    - decltype例子
      - 假定p的类型是int*，解引用生成左值，所以decltype(*p)的结果是一个&int；
      - 取地址符生成右值，所以decltype(&p)的结果是int**，指向指针的指针

#### 4.1.2 优先律与结合律

#### 4.1.3 求值顺序
  - 明确规定求职顺序的运算符:
    - 逻辑与运算符(`&&`):先求左侧运算对象的值，只有当左侧为真时，再求右侧；
    - 另外三种：逻辑或(`||`)、条件(`?:`)、逗号(`,`)

  - 求值顺序、优先级和结合律

### 4.2 算术运算符

### 4.3 逻辑和关系运算符
  - 逻辑与和逻辑或
    - 短路求值：逻辑与和逻辑或都是先确定左值，再求右值
  - 逻辑非：
  - 关系运算符：比较运算对象的大小关系，满足左结合律
  - 相等性测试和布尔字面值

### 4.4 赋值运算符
  - 赋值运算符的左侧必须是可修改的左值；
  - 如果左右两个运算对象的类型不同， 则右侧的对象类型转换为左侧；
  - 赋值运算符满足右结合律：
    ```c++
    int ival, jval;
    ival = jval = 0;
    ```
  - 赋值运算符优先级较低
  - 切勿混淆相等运算符和赋值运算符
  - 复合运算符: <=> `a = a op b`
    ```c++
     += -= *= /= %=
     <<= >>= &= ^= |=
     ```
### 4.5 递增和递减运算符

  - 递增和递减的前置版本和后置版本：
    - 前置版本(`++a`)：先加1，再用运算对象；将对象本身作为左值对象返回(建议用前置版本)
    - 后置版本(`a++`)：先用运算对象，再加1；讲对象的副本作为右值返回
  - 在一条语句中混用解引用和递增运算符
    ```c++
    auto pbeg = v.begin();
    std::cout << *pbeg++ << std::endl; //因为++的优先级高于*，所以先将迭代器++，然后解引用迭代器未增加的对象，最终返回pbeg的初始值的副本
    ```
  - 运算对象可按任意顺序求值， 容易造成行为未定义的错误

### 4.6 成员访问运算符

  - 点运算符(`.`)和箭头运算符(`->`)都可以用于访问成员；
    - 点(`.`)：获取类对象的一个成员；
    - 箭头运算符(`->`)：`ptr->mem`, 等价于`(*ptr).mem`


### 4.7 条件运算符

  - 条件运算符： `?:` => `cond ? expr1 : expr2`
  - 嵌套条件运算符：在条件运算符内部嵌套条件运算符
    - ```c++
      finalgrade = (grade > 90) ? "high grade" : (grade < 60) ? "fail" : "pass";
      ```
    - 满足右结合律
  - 在输出表达式中使用条件运算符：条件运算符优先级底，需要在两端加上括号
    ```c++
    cout <<  ((grade < 60) ? "fail" : "pass"); // 输出pass 或者 fail
    cout << (grade < 60) ? "fail" : "pass"; // 输出1或者0
    ```

### 4.8 位运算符

  - 位运算符:
    |   运算符  |  功能  |
    |----------|-------|
    |    ~     | 求反  |
    |    <<    |  左移  |
    |    >>    |  右移  |
    |    &     |  与   |
    |    ^     |  异或 |
    |    |     |  或   |
  - 移位运算符:`<<`、`>>`:
  - 求反运算符:`~`:将0置1，将1置0
  - 位与、位或、异或：
    ```
    unsigned char b1 = 0145; 0 1 1 0 0 1 0 1
    unsigned char b2 = 0257; 1 0 1 0 1 1 1 1
    b1 & b2 ===============> 0 0 1 0 0 1 0 1
    b1 | b2 ===============> 1 1 1 0 1 1 1 1
    b1 ^ b2 ===============> 1 1 0 0 1 0 1 0
    ```
  - 移位运算符（又叫IO运算符），满足左结合律

### 4.9 sizeof 运算符

  - `sizeof()`：返回表达式或类型的字节数，满足右结合律(不是求运算对象的值)
    - `sizeof(type)`、`sizeof expr`
    - 对数组使用sizeof，得到整个数组的大小，相当于对数组的每个元素执行一次sizeof

### 4.10 逗号运算符

  - 逗号运算符: 含有两个运算对象，执行从左往右的运算顺序。

### 4.11 类型转换

  - 类型转换:
    - 隐式转换(implicit conversion): 自动执行的类型转换
      - 举例:
        ```c++
        int ival =  3.54 + 3; // 整型先被转换为double类型，然后在初始化过程中，根据初始化类型对象转换为声明类型
        ```
    - 显式转换(explicit conversion):

#### 4.11.1 算术转换
  - 算术转换：在运算过程中，运算对象将转换成最宽的类型
  - 整型提升： 把小整数类型转换成较大的整数类型
  - 无符号类型的运算对象：(unsigned)
  - 理解算术转换
#### 4.11.2 其他隐式类型转换
  - 数组转换成指针
  - 指针的转换
  - 转换成布尔类型
  - 转换成常量
  - 类类型定义的转换

#### 4.11.3 显式类型转换

  - 命名的强制类型的转换；
   - `static_cast`、`const_cast`、`reinterpret_cast`、`dynamic_cast`（19.2节）
      - static_cast: 任何具有明确定义的类型转换，只要不包含底层const，都可以用static_cast
       ```c++
       double slope = static_cast<double>(j) / i;
       ```
        - 当需要把一个较大的算术类型赋值给较小的类型时，可以用static_cast
        - 可以使用static_cast找回存在于void*指针中的值
        ```c++
        void *p = &d;
        double *dp = static_cast<double*>(p);
        ```
      - const_cast:只能改变运算对象的底层const，只改变表达式的**常量**属性
       ```c++
       const char* pc;
       char* p = const_cast<char*>(pc); // 正确，但是通过p写值是未定义的
       ```
      - reinterpret_cast: 为运算对象的位模式提供较底层次的重新解释
### 4.12 运算符优先级表

## chapter 6 函数

### 6.1 函数基础

#### 6.1.1 局部对象

  - 名字有作用域，对象有生命周期
    - 名字的作用域是程序文本的一部分，名字在其中可见；
    - 对象的生命周期是程序执行过程中该对象存在的一段时间；
  - 自动对象: 当函数的控制路径经过变量定义语句时创建该对象，在到达定义所在块末尾时销毁它
  - 局部静态对象: 局部变量的生命周期贯穿在函数调用及之后的时间
    - 可以将局部变量声明成: `static size_t a = 0;`

#### 6.1.2 函数声明
  - 函数只能定义一次，但可以声明多次；
  - 在头文件中声明，在源文件中定义。

#### 6.1.3 分离式编译
  - 链接和编译多个源文件

### 6.2 参数传递

  - 每次函数调用都会创建形参，然后用对应的实参初始化形参
    - 引用传递(pass by reference): 绑定到对应的形参上
    - 值传递(pass by value): 将实参的值拷贝后赋给形参

### 6.2.1 传值参数

  - 使用传值参数，对变量的带动不会影响初始值；
  - 指针形参:
    - 执行<u>指针拷贝</u>时，拷贝的是指针的值，拷贝之后两个指针是不同的指针
    - 指针形参的行为类似: 拷贝后，改变指针(实参)的值，不改变地址，因为指针拷贝只是创建了一个地址不同的指针，但是指向对象的值一样，可以通过指针改变

### 6.2.2 传引用参数
  - 引用作用于引用所引用的对象本身；
  - 使用引用避免拷贝
  - 使用引用形参返回额外信息：将变量作为引用传入，然后再函数调用过程中对值进行修改，最后隐式返回
    - ```c++
      string::size_type find_char(const string &s, char c, string::size_type & occurs) {
        ...
           ++occurs;
        ...
        return ret;
      }

      ```

### 6.2.3 const形参和实参

  - 要注意： 顶层const作用于对象本身；
    - ```c++
      const int ci = 42; // 不能改变ci，const 是顶层
      int i = ci;        // 当拷贝ci时，忽略顶层const
      int * const p = &i; // const是顶层，不能给p赋值
      *p = 0;             // 正确: 通过p改变对象的内容是允许的，现在i变成了0
      ```
  - 指针或引用形参与const
  - 尽量使用常量引用，不能在函数中改变它的值

### 6.2.4 数组形参

  - 数组的两个性质: 1. 不允许拷贝数组 2. 使用数组时会将其转换成指针；
  - 1. 不能以值传递的方式使用数组参数；
  - 2. 管理指针形参有三种常用的技术
    - 使用标记制定数组长度
    - 使用标准库规范
    - 显示传递一个表示数组的形参``` void print(cosnt int ia[], size_t size)```
  - 数组形参和const
  - 数组引用形参：允许将变量定义成数组的引用```void print(int (&arr)[10])```
  - 传递多维数组

#### 6.2.5 main: 处理命令行选项

  - ```c++
    int main(int argc, char* argv[]) {}
    ```
  - 第一个形参`argc`表示数组中字符串的数量，第二个形参是一个数组，元素是指向C风格字符串的指针。

#### 6.2.6 含有可变形参的函数

  - 无法预知向函数传递几个参数，可以进行输入可变形参
    - 1.如果实参类型相同，可以传入initializer_list
    - 2. 如果类型不同，可以编写<font color=red>可变参数模板</font>(16.4 - 618)
  - initializer_list：
    ```c++
    initilizer_list<string> ls;
    ```
    > initializer_list对象中的元素永远是常量值，无法修改
  - 省略符形参: 只能出现在形参列表的最后一个位置
    - ```c++
      void foo(parm_list, ...)
      ```
### 6.3 返回类型和return语句

#### 6.3.1 无返回值函数

  - 没有返回值的return语句只能用在返回类型是void的函数中

#### 6.3.2 有返回值函数

  - 值是如何被返回的：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。返回时，返回值被拷贝到调用点。
  - **不要返回局部对象的引用或者指针**：函数结束以后，局部变量内存被释放，因此，引用或者指针无效。
  - 返回类类型的函数和调用运算符：
  - 引用返回左值：调用一个返回引用的函数得到左值，其他返回类型得到右值。
    - ```c++
      char &get_val(string& str, string::size_type ix) {
        return str[ix];
      }
      int main() {
        string s("a value");
        cout << s << endl;
        get_val(s, 0) = 'A';
        cout << s << endl;
        return 0;
      }
      ```
    - 如果返回类型是常量引用，那么不能给调用结果赋值
  - 列表初始化返回值：(C++11) 函数可以返回花括号包围的值的列表。
  - 主函数main的返回值
    - <font color=red>允许main函数没有return语句</font>，直接结束(如果控制到达了main函数的结尾处且没有return语句，编译器将隐式地插入一条返回0的return语句)
    - 返回0表示执行成功，其他表示执行失败。

  - 递归 (recursive function): 函数调用其自身
    - 递归函数必须含有终止条件，否则将不断调用直到程序栈空间耗尽为止

#### 6.3.3 返回数组指针

  - 因为数组不能被拷贝，因此函数不能返回数组，不过可以返回数组的指针或者引用；
  - 声明一个返回数组指针的函数
    - 返回数组指针的函数，后面必须跟着数组的维度
      ```c++
      // Type (*function(parameter_list)) [dimension]
      int (*func(int i))[10] // 解引用func的调用将得到一个大小是10的数组，其元素类型为int
      ```
  - 使用尾置返回类型
    ```c++
    auto func(int i) -> int(*)[10]// 返回一个指针，指针指向含有10个整数的数组
    ```
  - 使用decltype：如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型
    ```c++
    int odd[] = {1,3,5,7,9};
    int even[] = {0,2,4,6,8};
    //返回一个指针，该指针指向含有5个整数的数组
    decltype(odd) *arrPtr(int i) { // 用decltype表示返回的类型是一个指针
      return (i % 2) ? &odd : &even;
    }
    ```

### 6.4 函数重载

  - 同一作用域内，函数名字相同但是形式列表不同，称之为函数重载。
  - 定义重载函数
  - 判断两个形参的类型是否相异
  - 重载和const重载
    - 顶层const不影响传入函数的对象，一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来
    - 如果形参是指针或者引用，可以通过区分其指向的是常量对象还是非常量对象实现函数重载，此时的const是底层const
  - const_cast和重载: 通过const_cast实现常量引用和非常量引用之间的转换
    - ```c++
      const_cast<const string&>
      const_cast<string&>
      ```
  - 调用重载函数
   - 调用重载函数有可能的三只结果
     - 编译器找到一个和实参最佳匹配的函数
     - 找不到任何一个与调用实参匹配的函数，发出no match的错误信息
     - 有多于一个函数可以匹配，但都不是最佳调用，此时发生错误，成为二义性调用(ambiguous call)

#### 6.4.1 重载与作用域
  - 在不同的作用域内无法重载函数名

### 6.5 特殊用途语言特性

#### 6.5.1 默认实参

  - 使用默认实参调用函数
  - 默认实参声明
    - 一个形参只能被赋予一次默认实参
    - 形参右侧的所有形参必须都有默认值
  - 默认实参初始值
   - 局部变量不能作为默认实参，除此之外，只要表达式的类型能转换成形参所需的类型，该表达式就能作为默认实参


#### 6.5.2 内联函数和constexpr函数

  - 内联函数：将函数指定为内联，通常是将函数“内联地”展开，消除函数的运行时开销；
  - constexpr函数：指能用于常量表达式的函数。
    - 定义cosntexpr函数：函数的返回类型以及所有形参类型都是字面值类型，且函数体中只有一条return语句
    - 举例：
      ```c++
      constexpr int new_sz() {return 42;}
      constexpr int foo = new_sz();
      ```
    - 编译器把对constexpr函数的调用替换成其结果值，constexpr函数被隐式地指定为内联函数
  - 把内联函数和constexpr函数放在头文件中

#### 6.5.3 调试帮助

  - assert 和 NDEBUG
  - assert预处理宏
    - `assert (expr);`
    - 首先对expr求值，如果表达式为假（0），assert输出信息并终止程序的执行；如果为真，assert什么也不做
    - 和预处理变量一样，宏名字在程序内必须唯一
  - NDEBUG预处理变量
    - assert依赖于NDEBUG，如果定义了NDEBUG，则assert什么也不做，如果没有定义，assert执行运行时检查。
    - 如果NDEBUG未定义，将执行#ifndef和#endif之间的代码
      ```c++
      // example
      void print(cosnt int ia[], size_t size) {
        #ifndef NDEBUG
        // __func__
        cerr << __func__ << ": array size is " << size << endl;
        # endif
      }
    - 对于程序调试有用的名字:
      - `__func__`: 输出当前调试函数的名字
      - `__file__`: 存放文件名的字符串字面值
      - `__line__`: 存放当前行号的整型字面值
      - `__time__`: 存放文件编译时间的字符串字面值
      - `__data__`: 存放文件编译日期的字符串字面值

### 6.6 函数匹配

  - 确定候选函数和可行函数
    - 候选函数：1.与被调用函数同名 2. 函数声明在调用点可见；
    - 可行函数：1.形参与实参数量相同 3. 类型相同或者可以相互转换；
  - 寻找最佳匹配：形参与实参类型越接近越好
  - 含有多个形参的函数匹配

#### 6.6.1 实参类型转换
  - 需要类型提升和算术类型转换的匹配
  - 函数匹配和const实参

### 6.7 函数指针

## chapter 7 类

### 7.1 定义抽象数据类型

#### 7.1.1 设计Sales_data类

#### 7.1.2 定义改进的Sales_data类

#### 7.1.3 定义类相关的非成员函数

#### 7.1.4 构造函数

#### 7.1.5 拷贝、赋值和析构






## chapter 12 动态内存
### 12.1 动态内存与智能指针
  - 动态内存通过new和delete来管理
    - `new`: 在动态内存中为对象分配空间并返回一个指针
    - `delete`: 接受一个动态对象的指针，销毁该对象，并释放与之关联的内存
    - 为什么引入智能指针?
      - 为了防止内存泄露，智能指针能够自动释放所指对象
     - shared_ptr 和 unique_ptr区别
       - shared_ptr: 允许多个指针指向同一个对象
       - unique_ptr: “独占”所指对象
#### 12.1.1 shared_ptr类

#### 12.1.2 直接管理内存

#### 12.1.3 shared_ptr 和 new 结合使用
#### 12.1.4 智能指针和异常
#### 12.1.5 unique_ptr
#### 12.1.4 weak_ptr
####
####


## chapter 15 面向对象程序设计

### 15.1 OOP:概述

面向对象的核心思想数据抽象、继承和动态绑定


#### 2.2.2
####
####
####
####
